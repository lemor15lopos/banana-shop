<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banana Shooter - Defiende la Base</title>
    <!-- Tailwind CSS se carga desde CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el juego, incluyendo la fuente Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Fondo oscuro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Limitar el ancho para que el juego se vea bien en pantallas grandes */
            max-width: 600px; 
            width: 100%;
        }

        canvas {
            background-color: #2c3e50; /* Color de fondo del juego */
            display: block;
            border: 4px solid #f39c12; /* Borde naranja llamativo */
        }

        /* Estilo para la barra de vida */
        #health-bar-container {
            width: 100%;
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        #health-bar {
            height: 15px;
            background-color: #e74c3c; /* Rojo para la vida */
            transition: width 0.3s;
        }

        /* Estilos de botones y HUD */
        .game-ui {
            padding: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ecf0f1;
            background-color: #111;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .button-control {
            background-color: #f39c12;
            color: #1a1a2e;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #e67e22;
            user-select: none; /* Previene la selecci√≥n de texto al tocar */
        }

        .button-control:hover {
            background-color: #e67e22;
        }

        .button-control:active {
            transform: translateY(2px);
            box-shadow: 0 2px #e67e22;
        }

        /* Estilo para el mensaje de Power-Up */
        #powerup-display {
            font-size: 1rem;
            font-weight: bold;
            color: #2ecc71;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: rgba(46, 204, 113, 0.2);
            transition: all 0.5s;
        }
        
        /* Estilo para el mensaje de Power-Up de notificaci√≥n */
        #powerup-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: #f39c12;
            color: #1a1a2e;
            border-radius: 10px;
            font-size: 2rem;
            font-weight: 900;
            box-shadow: 0 0 20px #f39c12;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 10;
        }

        /* Pantalla de Elecci√≥n de Power-Up (Modal) */
        #powerup-choice-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none; /* Oculto por defecto */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            border-radius: 12px;
            padding: 20px;
        }

        #powerup-choice-screen h2 {
            font-size: 2.5rem;
            color: #2ecc71;
            margin-bottom: 20px;
        }

        .choice-button {
            margin: 10px;
            padding: 12px 24px;
            font-size: 1.2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .choice-accept {
            background-color: #2ecc71; /* Verde */
            color: white;
            box-shadow: 0 4px #27ae60;
        }

        .choice-accept:hover { background-color: #27ae60; }
        .choice-accept:active { transform: translateY(2px); box-shadow: 0 2px #27ae60; }

        .choice-reject {
            background-color: #e74c3c; /* Rojo */
            color: white;
            box-shadow: 0 4px #c0392b;
        }
        
        .choice-reject:hover { background-color: #c0392b; }
        .choice-reject:active { transform: translateY(2px); box-shadow: 0 2px #c0392b; }


        /* Estilo para el mensaje de Game Over */
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: none; /* Se oculta por defecto */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            border-radius: 12px;
        }
        #game-over-screen h1 {
            font-size: 3rem;
            color: #e74c3c;
            margin-bottom: 20px;
        }
        #final-score {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: #f39c12;
        }
    </style>
</head>
<body>

<div id="game-container" class="max-w-xl w-full">
    <div id="health-bar-container">
        <div id="health-bar"></div>
    </div>
    <!-- Canvas de juego, tama√±o fijo para el desarrollo -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Mensaje de Power-Up de notificaci√≥n -->
    <div id="powerup-message">POWER UP OBTENIDO!</div>

    <!-- Pantalla de Elecci√≥n de Power-Up -->
    <div id="powerup-choice-screen">
        <h2>¬°Power-Up Disponible!</h2>
        <p class="text-xl mb-4">¬øDeseas reemplazar tu Power-Up actual (<span id="current-powerup-name" class="font-bold text-yellow-400">Sin Power-Up</span>) por:</p>
        <p class="text-2xl mb-8 font-extrabold text-white" id="new-powerup-name"></p>
        
        <div class="flex space-x-4">
            <button id="acceptPowerup" class="choice-button choice-accept">Aceptar</button>
            <button id="rejectPowerup" class="choice-button choice-reject">Rechazar (Mantener el actual)</button>
        </div>
    </div>

    <div id="game-over-screen">
        <h1>¬°JUEGO TERMINADO!</h1>
        <p id="final-score">Puntuaci√≥n Final: 0</p>
        <button id="restartButton" class="button-control">Jugar de Nuevo</button>
    </div>

    <div class="game-ui">
        <span id="scoreDisplay" class="text-lg">Puntuaci√≥n: 0</span>
        <span id="powerup-display">Sin Power-Up</span>
        <!-- Bot√≥n visible en dispositivos peque√±os para disparar -->
        <button id="shootButton" class="button-control md:hidden">Disparar üçå</button>
    </div>
</div>

<!-- Bloque de Script del Juego -->
<script>
    // --- Game Logic ---
    const canvas = document.getElementById('gameCanvas');
    // Ensure canvas and context are obtained correctly
    if (!canvas) {
        console.error("Canvas element not found.");
    }
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const healthBar = document.getElementById('health-bar');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreDisplay = document.getElementById('final-score');
    const restartButton = document.getElementById('restartButton');
    const shootButton = document.getElementById('shootButton'); 
    const powerupDisplay = document.getElementById('powerup-display');
    const powerupMessage = document.getElementById('powerup-message');
    const powerupChoiceScreen = document.getElementById('powerup-choice-screen');
    const currentPowerupName = document.getElementById('current-powerup-name');
    const newPowerupName = document.getElementById('new-powerup-name');
    const acceptPowerupButton = document.getElementById('acceptPowerup');
    const rejectPowerupButton = document.getElementById('rejectPowerup');

    
    // Canvas Dimensions
    const GAME_WIDTH = 600;
    const GAME_HEIGHT = 400;

    // Assign dimensions to canvas
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // Power-Up Constants
    const BASE_SPEED = 5;
    const KILLS_TO_POWERUP = 20;

    // Game state variables
    let player = {
        x: 50,
        y: GAME_HEIGHT / 2,
        width: 30,
        height: 30,
        speed: BASE_SPEED, // Base speed
        health: 125, 
        maxHealth: 125, 
        hasShield: false // Shield Power-Up state
    };

    let bananas = [];
    let zombies = [];
    let particles = [];
    let score = 0;
    let isGameOver = false;
    let gameRunning = false;
    let isPaused = false; // To pause the game during Power-Up choice
    
    // Power-Up variables
    let killsSincePowerup = 0;
    let activePowerup = null; // null, 'TRIPLE', 'PIERCE', 'SPEED', 'SHIELD', 'BIG_BANANA'
    let powerupOption = null; // Power-Up offered for choice

    // Zombie spawn rate: 60 frames between each spawn (1 per second)
    let zombieSpawnRate = 60; 
    let frameCount = 0;

    let keys = {
        up: false,
        down: false,
        shoot: false 
    };

    // Power-Up Name Mapping
    const POWERUP_NAMES = {
        'TRIPLE': 'Triple Disparo üçåüçåüçå',
        'PIERCE': 'Perforaci√≥n üí•',
        'SPEED': 'Velocidad ‚ö°',
        'SHIELD': 'Escudo üõ°Ô∏è',
        'BIG_BANANA': 'Banana Gigante üåï'
    };


    // --- Game Classes (Models) ---

    // Class for Bananas (Projectiles)
    class Banana {
        constructor(x, y, type = 'NORMAL') {
            this.x = x;
            this.y = y;
            this.velocity = 8;
            this.color = '#f1c40f'; // Banana yellow
            this.isPiercing = (type === 'PIERCE');
            this.isBig = (type === 'BIG_BANANA');

            if (this.isBig) {
                this.radius = 8;
                this.velocity = 6; // Slower because it's bigger
            } else {
                this.radius = 5;
                this.velocity = 8;
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // Visual indicators
            if (this.isPiercing) {
                 ctx.strokeStyle = '#c0392b'; // Red border
                 ctx.lineWidth = 1;
                 ctx.stroke();
            }
            if (this.isBig) {
                 ctx.strokeStyle = '#fff'; // White border to highlight size
                 ctx.lineWidth = 1;
                 ctx.stroke();
            }
        }

        update() {
            this.x += this.velocity;
        }
    }

    // Class for Zombies (Enemies)
    class Zombie {
        constructor(type = 'NORMAL') {
            this.x = GAME_WIDTH;
            this.y = Math.random() * (GAME_HEIGHT - 40) + 20; // Random Y position
            this.type = type;
            this.width = 20;
            this.height = 20;
            this.points = 10; // Base score
            this.maxHealth = 1; // Base health
            
            // Adjustments by type
            if (this.type === 'FAST') {
                this.speed = Math.random() * 1.5 + 1.2; // Faster
                this.color = '#e74c3c'; // Red for Fast
                this.points = 15;
            } else if (this.type === 'TANK') {
                this.speed = Math.random() * 0.4 + 0.2; // Slower
                this.width = 30; // Bigger
                this.height = 30;
                this.color = '#34495e'; // Dark gray for Tank
                this.maxHealth = 3; // More resistant
                this.points = 30;
            } else if (this.type === 'BRUTE') { // NEW Brute Zombie (Purple)
                this.speed = Math.random() * 1 + 0.8; // Medium speed
                this.width = 25; // Intermediate size
                this.height = 25;
                this.color = '#8e44ad'; // Purple
                this.maxHealth = 6; // 6 health
                this.points = 50; // High points for health
            } else { // NORMAL
                this.speed = Math.random() * 0.8 + 0.5; // Normal speed
                this.color = '#27ae60'; // Green
            }
            
            this.currentHealth = this.maxHealth;
        }

        draw() {
            // Draw zombie body
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // Eyes
            ctx.fillStyle = (this.type === 'TANK' || this.type === 'BRUTE') ? '#f39c12' : '#c0392b';
            ctx.fillRect(this.x + 4, this.y + 4, 4, 4);
            ctx.fillRect(this.x + this.width - 8, this.y + 4, 4, 4);
            
            // If Tank or Brute, show remaining health
            if (this.type === 'TANK' || this.type === 'BRUTE') {
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`HP: ${this.currentHealth}`, this.x + this.width / 2, this.y + this.height + 10);
            }
        }

        update() {
            this.x -= this.speed;
        }
    }

    // Class for Explosion Particles
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.radius = Math.random() * 2 + 1;
            this.color = color;
            this.velocity = {
                x: (Math.random() - 0.5) * (Math.random() * 4),
                y: (Math.random() - 0.5) * (Math.random() * 4)
            };
            this.alpha = 1;
            this.friction = 0.99;
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }

        update() {
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.alpha -= 0.02; // Fade out
        }
    }


    // --- Game Functions ---
    
    // Function to draw the base the player defends
    function drawBase() {
        const BASE_WIDTH = 50;
        const BASE_COLOR = '#3498db'; // Blue for the house
        const ROOF_COLOR = '#e74c3c'; // Red for the roof
        const WINDOW_COLOR = '#f1c40f'; // Yellow for the windows

        // 1. Draw the house body
        ctx.fillStyle = BASE_COLOR;
        ctx.fillRect(0, 0, BASE_WIDTH, GAME_HEIGHT);

        // 2. Draw the roof (Triangle)
        ctx.fillStyle = ROOF_COLOR;
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(BASE_WIDTH, 0); 
        ctx.lineTo(BASE_WIDTH / 2, 50); // Roof peak
        ctx.closePath();
        ctx.fill();
        
        // 3. Draw some windows (yellow rectangles)
        ctx.fillStyle = WINDOW_COLOR;
        ctx.fillRect(10, 80, 15, 15);
        ctx.fillRect(25, 120, 15, 15);
        ctx.fillRect(10, GAME_HEIGHT - 100, 15, 15);
        
        // 4. Draw a "door" (darker rectangle)
        ctx.fillStyle = '#2c3e50'; 
        ctx.fillRect(20, GAME_HEIGHT - 40, 15, 40);
        
        // The "META" text has been removed as per user request.
    }


    function initializeGame() {
        if (gameRunning) return;
        gameRunning = true;
        isPaused = false;
        
        // Reset player and game states
        player.health = 125; 
        player.maxHealth = 125; 
        player.y = GAME_HEIGHT / 2; // Initial central position
        player.speed = BASE_SPEED; // Reset speed
        player.hasShield = false; // Reset shield
        score = 0;
        isGameOver = false;
        bananas = [];
        zombies = [];
        particles = [];
        frameCount = 0;
        zombieSpawnRate = 60; // 1 zombie per second
        
        // Reset Power-Up
        killsSincePowerup = 0;
        activePowerup = null;
        powerupOption = null;
        updatePowerupDisplay();
        
        // Hide screens and update UI
        gameOverScreen.style.display = 'none';
        powerupChoiceScreen.style.display = 'none';
        updateHealthBar();
        updateScore();
        
        // Start the animation loop
        animate(); 
    }

    // Function that applies the selected Power-Up to the player
    function applyPowerup(newPowerup) {
        // 1. Reset all active effects
        player.speed = BASE_SPEED; 
        player.hasShield = false;
        
        // 2. Apply the new Power-Up
        activePowerup = newPowerup;

        if (activePowerup === 'SPEED') {
            player.speed = BASE_SPEED * 2; // Double speed
        } else if (activePowerup === 'SHIELD') {
            player.hasShield = true; // Activate shield
        }
        
        // 3. Reset counter and notify
        killsSincePowerup = 0;
        updatePowerupDisplay();
        showPowerupMessage(POWERUP_NAMES[newPowerup]);
    }


    // Function to select a Power-Up and pause for choice
    function grantPowerup() {
        // List of available Power-Ups
        const powerupOptions = ['TRIPLE', 'PIERCE', 'SPEED', 'SHIELD', 'BIG_BANANA'];
        
        // Select a random Power-Up
        const randomIndex = Math.floor(Math.random() * powerupOptions.length);
        powerupOption = powerupOptions[randomIndex];

        // Pause the game
        isPaused = true; 
        powerupChoiceScreen.style.display = 'flex';

        // Update the choice modal
        const currentName = activePowerup ? POWERUP_NAMES[activePowerup] : 'Ninguno';
        currentPowerupName.textContent = currentName;
        newPowerupName.textContent = POWERUP_NAMES[powerupOption];
        
        // Reset counter while the game is paused 
        killsSincePowerup = 0; 
    }
    
    // Shows a temporary message in the center of the screen
    function showPowerupMessage(name) {
        powerupMessage.textContent = `${name} ACTIVO!`;
        powerupMessage.style.opacity = 1;
        setTimeout(() => {
            powerupMessage.style.opacity = 0;
        }, 1500);
    }

    // Updates the Power-Up text in the HUD
    function updatePowerupDisplay() {
        // Show active Power-Up or progress
        let displayText = 'Sin Power-Up';
        
        if (activePowerup) {
            displayText = POWERUP_NAMES[activePowerup];
            // Show shield status if active
            if (activePowerup === 'SHIELD' && player.hasShield) {
                 displayText += ' (Listo)';
            }
            powerupDisplay.classList.remove('text-ecf0f1', 'bg-transparent');
            powerupDisplay.classList.add('text-yellow-400', 'bg-yellow-400/20');
        } else {
            powerupDisplay.classList.remove('text-yellow-400', 'bg-yellow-400/20');
            powerupDisplay.classList.add('text-ecf0f1', 'bg-transparent');
        }

        // If no active Power-Up OR game is paused, show progress
        if (!activePowerup || isPaused) {
            powerupDisplay.textContent = `Power-Up: ${killsSincePowerup}/${KILLS_TO_POWERUP}`;
        } else {
            powerupDisplay.textContent = displayText;
        }

    }


    // Shooting function (creates a new banana)
    function shoot() {
        const yCenter = player.y + player.height / 2;
        const xStart = player.x + player.width;
        
        // Determine banana type
        let bananaType = 'NORMAL';
        if (activePowerup === 'PIERCE') bananaType = 'PIERCE';
        if (activePowerup === 'BIG_BANANA') bananaType = 'BIG_BANANA';


        // Base shot
        bananas.push(new Banana(xStart, yCenter, bananaType));

        // Triple Shot Power-Up
        if (activePowerup === 'TRIPLE') {
            // Upper shot
            bananas.push(new Banana(xStart, yCenter - 10, bananaType));
            // Lower shot
            bananas.push(new Banana(xStart, yCenter + 10, bananaType));
        }
    }

    // Functions to handle Power-Up choice
    function acceptPowerup() {
        if (!powerupOption) return;
        applyPowerup(powerupOption);
        powerupOption = null;
        powerupChoiceScreen.style.display = 'none';
        isPaused = false;
        animate(); // Resume loop
    }

    function rejectPowerup() {
        // Simply discard the option and resume the game.
        powerupOption = null;
        // Only reset the kill counter if the current Power-Up is NOT null
        if (activePowerup) {
             killsSincePowerup = 0;
        }
        updatePowerupDisplay();
        powerupChoiceScreen.style.display = 'none';
        isPaused = false;
        animate(); // Resume loop
    }


    // Function to handle collisions
    function handleCollisions() {
        // Collisions between Bananas and Zombies
        for (let i = bananas.length - 1; i >= 0; i--) {
            const banana = bananas[i];
            let hit = false; // Flag to know if this banana hit something

            for (let j = zombies.length - 1; j >= 0; j--) {
                const zombie = zombies[j];

                // Collision detection
                if (
                    banana.x + banana.radius > zombie.x &&
                    banana.x - banana.radius < zombie.x + zombie.width &&
                    banana.y + banana.radius > zombie.y &&
                    banana.y - banana.radius < zombie.y + zombie.height
                ) {
                    // Collision
                    
                    // Reduce zombie health
                    zombie.currentHealth--;

                    // Particle effect (using banana color for impact)
                    for (let k = 0; k < 5; k++) { 
                        particles.push(new Particle(banana.x, banana.y, '#f1c40f')); 
                    }
                    
                    // Check if the zombie dies
                    if (zombie.currentHealth <= 0) {
                        
                        // Death particle effect (using zombie color)
                        for (let k = 0; k < 15; k++) { 
                            particles.push(new Particle(zombie.x + zombie.width / 2, zombie.y + zombie.height / 2, zombie.color));
                        }
                        
                        // Remove the zombie
                        zombies.splice(j, 1);
                        
                        // Increase score and Power-Up counter based on zombie type
                        score += zombie.points; 
                        killsSincePowerup++;
                        updateScore();
                        updatePowerupDisplay();

                        // Check for Power-Up grant
                        if (killsSincePowerup >= KILLS_TO_POWERUP && !isPaused) {
                            grantPowerup();
                        }
                        
                    } // End if zombie dies
                    
                    hit = true;

                    // If the banana is NOT piercing, it's consumed and checking stops
                    if (!banana.isPiercing) {
                        break; 
                    }
                    // If it is piercing, continue iterating to hit the next zombie
                }
            }

            // If the banana is NOT piercing AND hit, or if it went off screen, remove it.
            if ((hit && !banana.isPiercing) || banana.x > GAME_WIDTH) {
                bananas.splice(i, 1);
            }
        }

        // Collision between Zombies and Player (if the zombie reaches the left side)
        for (let i = zombies.length - 1; i >= 0; i--) {
            const zombie = zombies[i];

            if (zombie.x < player.x + player.width) {
                // Zombie reached the player's base

                // 1. Check if the player has a shield
                if (player.hasShield) {
                    player.hasShield = false; // Break the shield
                    updatePowerupDisplay();
                    // Shield visual notification
                    for (let k = 0; k < 20; k++) {
                        particles.push(new Particle(player.x, player.y + player.height / 2, '#3498db')); // Blue particles
                    }
                    // Remove the zombie, but do not reduce health
                    zombies.splice(i, 1); 
                    continue; // Go to the next zombie
                }

                // 2. If no shield, reduce health
                player.health -= 15; 
                updateHealthBar();
                
                // Remove the zombie
                zombies.splice(i, 1);

                // Check for Game Over
                if (player.health <= 0) {
                    player.health = 0;
                    isGameOver = true;
                    showGameOver();
                }
            }
        }
    }

    // Function to update the health bar in the DOM
    function updateHealthBar() {
        const percentage = (player.health / player.maxHealth) * 100;
        healthBar.style.width = `${percentage}%`;
        
        // Color change based on remaining health
        if (percentage < 30) {
             healthBar.style.backgroundColor = '#c0392b'; // Critical Red
        } else if (percentage < 60) {
             healthBar.style.backgroundColor = '#e67e22'; // Orange
        } else {
             healthBar.style.backgroundColor = '#2ecc71'; // Green
        }
    }

    // Function to update the score in the DOM
    function updateScore() {
        scoreDisplay.textContent = `Puntuaci√≥n: ${score}`;
    }
    
    // Function to show the Game Over screen
    function showGameOver() {
        gameRunning = false;
        gameOverScreen.style.display = 'flex';
        finalScoreDisplay.textContent = `Puntuaci√≥n Final: ${score}`;
    }


    // --- Main Game Loop ---
    function animate() {
        if (isGameOver || !gameRunning || isPaused) return; 

        // 1. Clear the Canvas
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        
        // 1.5. Draw the defending base (before the player)
        drawBase();

        // 2. Player Movement
        if (keys.up && player.y > 0) {
            player.y -= player.speed;
        }
        if (keys.down && player.y < GAME_HEIGHT - player.height) {
            player.y += player.speed;
        }

        // 3. Zombie Generation
        frameCount++;
        if (frameCount % Math.floor(zombieSpawnRate) === 0) {
            // Logic to choose zombie type:
            let zombieType = 'NORMAL';
            const random = Math.random();
            
            if (random < 0.15) { // 15% Fast Zombie (Red)
                zombieType = 'FAST';
            } else if (random < 0.25) { // 10% Tank Zombie (Gray)
                zombieType = 'TANK';
            } else if (random < 0.30) { // 5% NEW Brute Zombie (Purple)
                zombieType = 'BRUTE';
            }
            // 70% Normal Zombie (Green)

            zombies.push(new Zombie(zombieType));
            
            // Increase difficulty (faster spawn rate)
            if (zombieSpawnRate > 20) {
                zombieSpawnRate -= 0.1; 
            }
        }

        // 4. Update and Draw Zombies
        zombies.forEach((zombie) => {
            zombie.update();
            zombie.draw();
        });

        // 5. Update and Draw Bananas
        for (let i = bananas.length - 1; i >= 0; i--) {
            const banana = bananas[i];
            banana.update();
            banana.draw();

            // Removal for going off screen is handled in handleCollisions 
        }
        
        // 6. Update and Draw Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const particle = particles[i];
            particle.update();
            particle.draw();

            // Remove faded particles
            if (particle.alpha <= 0 || particle.radius < 0.5) {
                particles.splice(i, 1);
            }
        }

        // 7. Draw Player (yellow rectangle)
        ctx.fillStyle = '#f1c40f'; 
        ctx.fillRect(player.x, player.y, player.width, player.height);
        
        // Draw shield border if active
        if (player.hasShield) {
            ctx.strokeStyle = '#3498db'; // Blue
            ctx.lineWidth = 3;
            ctx.strokeRect(player.x - 2, player.y - 2, player.width + 4, player.height + 4);
        }

        // 8. Handle Collisions
        handleCollisions();

        // 9. Request the next frame
        requestAnimationFrame(animate);
    }

    // --- Event Handlers ---

    // Keyboard movement (W/S or arrows)
    document.addEventListener('keydown', (e) => {
        if (isPaused) return; // Ignore input if paused
        
        if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            keys.up = true;
        } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
            keys.down = true;
        } else if (e.key === ' ' && !keys.shoot && !isGameOver) { 
            // The keys.shoot flag prevents automatic shooting if held down
            keys.shoot = true;
            shoot(); 
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            keys.up = false;
        } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
            keys.down = false;
        } else if (e.key === ' ') {
            keys.shoot = false;
        }
    });

    // Shooting control for mobile devices (button)
    shootButton.addEventListener('click', () => {
        if (!isGameOver && !isPaused) {
            shoot();
        }
    });

    // Shooting control with left mouse click
    canvas.addEventListener('mousedown', (e) => {
        // e.button === 0 is the left mouse click
        if (e.button === 0 && !isGameOver && !isPaused) {
            e.preventDefault(); // Prevents default browser behavior (e.g., selection)
            shoot();
        }
    });

    // Power-Up modal events
    acceptPowerupButton.addEventListener('click', acceptPowerup);
    rejectPowerupButton.addEventListener('click', rejectPowerup);


    // Restart button
    restartButton.addEventListener('click', () => {
        initializeGame();
    });

    // Touch control for movement 
    canvas.addEventListener('touchstart', (e) => {
        if (isPaused) return;
        e.preventDefault(); // Important to prevent scrolling
        
        // Determine if the touch is in the upper or lower half of the canvas
        const touchY = e.touches[0].clientY;
        const rect = canvas.getBoundingClientRect();
        const relativeY = touchY - rect.top;

        if (relativeY < rect.height / 2) {
            keys.up = true;
            keys.down = false;
        } else {
            keys.down = true;
            keys.up = false;
        }
    });

    canvas.addEventListener('touchend', (e) => {
        if (isPaused) return;
        e.preventDefault();
        keys.up = false;
        keys.down = false;
    });

    // Start the game when the window loads
    window.onload = initializeGame;
</script>

</body>
</html>
